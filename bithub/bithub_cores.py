"""
BITCORE CORES MODULE (CORE SYNAPSE)

Definitions:
- Core Synapse: A genesis event triggered by creating a New Topic in a Core Subcategory.
- Seed: The output generated by the workflow, captured as the First Reply.

Why: Enables the instantiation of complex agentic workflows (Nerves) and the harvesting of their seeds.
What: Opens Core Synapses (Triggers) and monitors them for completion signals.
How: Extends BithubComms to add genesis and observation capabilities.
"""

import sys
from typing import List, Optional, Dict, Any
from .bithub_comms import BithubComms
from .bithub_config import DEFAULT_CATEGORY_ID, DEFAULT_TIMEOUT

class BithubCores(BithubComms):
    """Extended Bithub communication handler for CORES workflow deployments.

    Inherits authentication and transport logic from BithubComms.
    """

    def create_public_topic(self, title: str, raw: str, category_id: int) -> Dict[str, Any]:
        """Creates a new public topic in a specific category.

        Args:
            title: The title of the topic.
            raw: The raw content of the first post.
            category_id: The ID of the category where the topic will be created.

        Returns:
            A dictionary containing the API response from the Discourse instance.

        Raises:
            BithubError: If the API request fails.
        """
        payload = {
            "title": title,
            "raw": raw,
            "category": category_id
        }
        return self._request("POST", "/posts.json", json_data=payload)

    
    def deploy_seed(self, title: str, category_id: int = DEFAULT_CATEGORY_ID) -> Dict[str, Any]:
        """Deploys a seed topic with a placeholder message.

        Args:
            title (str): The title of the seed topic.
            category_id (int): The category ID. Defaults to DEFAULT_CATEGORY_ID.

        Returns:
            Dict[str, Any]: A dictionary containing 'topic_id' and 'post_id'.
        """
        placeholder = "ðŸŒ± **CORE SEED INITIALIZED**... awaiting payload."
        resp = self.create_public_topic(title, placeholder, category_id)
        return {
            "topic_id": resp['topic_id'],
            "post_id": resp['id']
        }

    def refine_seed(self, post_id: int, content: str) -> Dict[str, Any]:
        """Refines a seed post with the actual content.

        Args:
            post_id (int): The ID of the post to update.
            content (str): The new content.

        Returns:
            Dict[str, Any]: The API response.
        """
        return self.update_post(post_id, content)

    def deploy_only(
        self,
        title: str,
        content: str,
        category_id: int = DEFAULT_CATEGORY_ID,
        tags: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """Deploys a workflow by creating a topic but DOES NOT wait for a response.

        Args:
            title: Title of the topic/workflow.
            content: The main instruction or payload.
            category_id: Target category ID (default DEFAULT_CATEGORY_ID).
            tags: List of bot usernames to tag (e.g., ['@bitbot']).

        Returns:
            A dictionary containing 'topic_id', 'post_id', and 'status'.

        Raises:
            BithubError: If deployment fails.
        """
        # 1. Prepare Content (Tags are applied later in refinement phase, not here)
        full_content = content
        # Logic to prepend tags removed to prevent context leakage during initial deployment

        sys.stderr.write(f"[Cores] Deploying '{title}' to Category {category_id}...\n")

        # 2. Create Topic
        # Raises BithubError on failure, so we assume success if we proceed.
        resp = self.create_public_topic(title, full_content, category_id)

        topic_id = resp['topic_id']
        initial_post_id = resp['id']
        sys.stderr.write(f"[Cores] Deployed successfully. Topic ID: {topic_id}.\n")

        return {
            "topic_id": topic_id,
            "post_id": initial_post_id,
            "status": "deployed"
        }

    def signal_completion_sanitized(self, public_channel_id: int, private_topic_id: int) -> Dict[str, Any]:
        """Signals completion to a public channel without leaking private context IDs.

        Args:
            public_channel_id: The ID of the public topic/channel to post to.
            private_topic_id: The ID of the private topic (used for internal tracking/logging only).

        Returns:
            API response from the post creation.
        """
        # We do NOT include private_topic_id in the message text to prevent leaks.
        message = "âœ… Core Task Completed. [Private Context]"

        sys.stderr.write(f"[Cores] Signaling completion to Public Channel {public_channel_id} for Private Topic {private_topic_id}...\n")

        payload = {
            "topic_id": public_channel_id,
            "raw": message
        }
        return self._request("POST", "/posts.json", json_data=payload)

    def watch_topic(
        self,
        topic_id: int,
        last_post_id: int,
        timeout: int = DEFAULT_TIMEOUT
    ) -> Optional[Dict[str, Any]]:
        """Watches an existing topic for a new reply.

        Args:
            topic_id: The ID of the topic to watch.
            last_post_id: The ID of the last known post (to wait for a newer one).
            timeout: Max seconds to wait.

        Returns:
            The response post object if received, None otherwise.

        Raises:
            BithubError: If polling fails.
        """
        sys.stderr.write(f"[Cores] Watching Topic {topic_id} for response (timeout: {timeout}s)...\n")

        # Monitor for Response
        reply = self.wait_for_reply(topic_id, last_post_id, timeout=timeout)

        if reply:
            sys.stderr.write(f"[Cores] Signal received from Post ID {reply['id']}.\n")
            return reply
        else:
            sys.stderr.write(f"[Cores] Timeout ({timeout}s) reached. No completion signal detected.\n")
            return None

    def deploy_core(
        self,
        title: str,
        content: str,
        category_id: int = DEFAULT_CATEGORY_ID,
        tags: Optional[List[str]] = None,
        timeout: int = DEFAULT_TIMEOUT,
        sync: bool = False,
        burn: bool = False
    ) -> Optional[Dict[str, Any]]:
        """Deploys a workflow by creating a topic and waiting for a response.

        Wrapper around deploy_only and watch_topic.

        Args:
            title: Title of the topic/workflow.
            content: The main instruction or payload.
            category_id: Target category ID (default DEFAULT_CATEGORY_ID).
            tags: List of bot usernames to tag (e.g., ['@bitbot']).
            timeout: Max seconds to wait for a response.
            sync: If True, wait for a reply. Defaults to False.
            burn: If True, delete the topic after receiving a reply. Defaults to False.

        Returns:
            The response post object if successful, None otherwise.

        Raises:
            BithubError: If deployment or watching fails.
        """
        deployment = self.deploy_only(title, content, category_id, tags)
        # deployment is guaranteed to be a dict here because deploy_only raises on failure

        if not sync:
            return deployment

        result = self.watch_topic(deployment['topic_id'], deployment['post_id'], timeout)

        if sync and burn and result:
            sys.stderr.write(f"[Cores] Burning (deleting) Topic {deployment['topic_id']} after sync...\n")
            try:
                self.delete_topic(deployment['topic_id'])
            except Exception as e:
                sys.stderr.write(f"[Cores] Failed to burn topic: {e}\n")

        return result

# Usage Example / CLI Test
if __name__ == "__main__":
    if len(sys.argv) < 2:
        sys.stderr.write("Usage: python bithub_cores.py <title> [content] [category_id]\n")
        sys.stderr.write("Example: python bithub_cores.py 'Test Workflow' 'Run diagnostics' 55\n")
        sys.exit(1)

    title_arg = sys.argv[1]
    content_arg = sys.argv[2] if len(sys.argv) > 2 else "Ping workflow check."
    cat_arg = int(sys.argv[3]) if len(sys.argv) > 3 else DEFAULT_CATEGORY_ID

    try:
        cores = BithubCores()
        # Example: Tagging a hypothetical bot '@BITcore_bot'
        result = cores.deploy_core(
            title=title_arg,
            content=content_arg,
            category_id=cat_arg,
            tags=['@BITcore_bot'],
            timeout=45
        )

        if result:
            clean_text = cores.sanitize_html(result.get('cooked', ''))
            print(f"\n[Result] Workflow Output:\n{clean_text}\n")
        else:
            sys.exit(1)

    except Exception as e:
        sys.stderr.write(f"[Fatal] {e}\n")
